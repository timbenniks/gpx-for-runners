{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///gpx.min.js","webpack:///webpack/bootstrap fddbf6286392c727d018","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","value","GPX","gpxContent","xmlDoc","DOMParser","parseFromString","trkpts","querySelectorAll","trackpoints","createJsonFromGpxDom","Error","trkpt","push","lon","parseFloat","getAttribute","lat","elevation","querySelector","textContent","time","start","Date","end","timeDiff","Math","abs","getTime","total","millisecondsToTime","totalMS","duration","seconds","parseInt","minutes","hours","days","hoursDays","arguments","undefined","distance","getUTCMinutes","getUTCSeconds","eleForMinMax","richElevation","gain","loss","startTime","dist","diff","calcDistanceBetweenPoints","max","apply","min","distanceInKm","wp1","wp2","point1","PI","alt","point2","dp","asin","sqrt","pow","sin","cos","d","h"],"mappings":"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","file":"gpx.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"gpx\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gpx\"] = factory();\n\telse\n\t\troot[\"gpx\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"gpx\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gpx\"] = factory();\n\telse\n\t\troot[\"gpx\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * GPX parser class\n\t * @class GPX\n\t */\n\t\n\tvar GPX = function () {\n\t\n\t  /**\n\t   * GPX constructor.\n\t   * @param {string} gpxContent String of gpx XML data.\n\t   * @constructs GPX\n\t   */\n\t\n\t  function GPX(gpxContent) {\n\t    _classCallCheck(this, GPX);\n\t\n\t    /**\n\t     * string of gpx XML data.\n\t     * @member GPX#gpxContent\n\t     */\n\t    this.gpxContent = gpxContent;\n\t\n\t    /**\n\t     * The parsed gpx string into a DOM object.\n\t     * @member GPX#xmlDoc\n\t     */\n\t    this.xmlDoc = new DOMParser().parseFromString(this.gpxContent, 'application/xml');\n\t\n\t    /**\n\t     * Object of all trackpoints in the gpx DOM.\n\t     * @member GPX#trkpts\n\t     */\n\t    this.trkpts = this.xmlDoc.querySelectorAll('trkpt');\n\t\n\t    /**\n\t     * All trackpoints as an Array\n\t     * @member GPX#trackpoints\n\t     */\n\t    this.trackpoints = this.createJsonFromGpxDom();\n\t\n\t    if (this.trackpoints.length === 0) {\n\t      throw new Error('This file has no trackpoints (trkpt)');\n\t    }\n\t  }\n\t\n\t  /**\n\t   * @typedef TrackPoint\n\t   * @type Object\n\t   * @property {number} lon The lon coordinate of the trackpoint\n\t   * @property {number} lat The lat coordinate of the trackpoint\n\t   * @property {number} elevation The elevation in meters of the trackpoint\n\t   * @property {string} time The time of the trackpoint\n\t   */\n\t\n\t  /**\n\t   * Loops over gpx DOM and returns array of objects\n\t   * @return {TrackPoint} The trackpoint data\n\t   */\n\t\n\t  _createClass(GPX, [{\n\t    key: 'createJsonFromGpxDom',\n\t    value: function createJsonFromGpxDom() {\n\t      var trackpoints = [];\n\t\n\t      for (var trkpt = 0; trkpt < this.trkpts.length; trkpt++) {\n\t        trackpoints.push({\n\t          lon: parseFloat(this.trkpts[trkpt].getAttribute('lon')),\n\t          lat: parseFloat(this.trkpts[trkpt].getAttribute('lat')),\n\t          elevation: parseFloat(this.trkpts[trkpt].querySelector('ele').textContent),\n\t          time: this.trkpts[trkpt].querySelector('time').textContent\n\t        });\n\t      };\n\t\n\t      return trackpoints;\n\t    }\n\t\n\t    /**\n\t     * @typedef Duration\n\t     * @type Object\n\t     * @property {date} start The start time of the run as a Date object\n\t     * @property {date} end The end time of the run as a Date object\n\t     * @property {number} totalMS The duration of the run in miliseconds\n\t     * @property {string} total The duration of the run in human readable form\n\t     */\n\t\n\t    /**\n\t     * Returns the duration of the run.\n\t     * @return {Duration} The duration information of the run.\n\t     */\n\t\n\t  }, {\n\t    key: 'duration',\n\t    value: function duration() {\n\t      var start = new Date(this.trackpoints[0].time),\n\t          end = new Date(this.trackpoints[this.trackpoints.length - 1].time),\n\t          timeDiff = Math.abs(end.getTime() - start.getTime()),\n\t          total = this.millisecondsToTime(timeDiff);\n\t\n\t      return {\n\t        start: start,\n\t        end: end,\n\t        totalMS: timeDiff,\n\t        total: total\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Returns humanized time for miliseconds.\n\t     * @param {string} duration Duration in milliseconds\n\t     * @return {string} Readable time\n\t     */\n\t\n\t  }, {\n\t    key: 'millisecondsToTime',\n\t    value: function millisecondsToTime(duration) {\n\t      var seconds = parseInt(duration / 1000 % 60, 10),\n\t          minutes = parseInt(duration / (1000 * 60) % 60, 10),\n\t          hours = parseInt(duration / (1000 * 60 * 60) % 24, 10),\n\t          days = parseInt(duration / (1000 * 60 * 60 * 24), 10),\n\t          hoursDays = parseInt(days * 24, 10);\n\t\n\t      hours += hoursDays;\n\t      hours = hours < 10 ? '0' + hours : hours;\n\t      minutes = minutes < 10 ? '0' + minutes : minutes;\n\t      seconds = seconds < 10 ? '0' + seconds : seconds;\n\t      return hours === '00' ? minutes + ':' + seconds : hours + ':' + minutes + ':' + seconds;\n\t    }\n\t\n\t    /**\n\t     * @typedef Pace\n\t     * @type Object\n\t     * @property {number} minutes The minutes part of the pace time.\n\t     * @property {number} seconds The seconds part of the pace time.\n\t     */\n\t\n\t    /**\n\t     * Returns pace of the run.\n\t     * @param {number} duration Duration in milliseconds.\n\t     * @param {number} distance Distance in kilometers.\n\t     * @return {Pace} The Pace\n\t     */\n\t\n\t  }, {\n\t    key: 'pace',\n\t    value: function pace() {\n\t      var duration = arguments.length <= 0 || arguments[0] === undefined ? this.duration().totalMS : arguments[0];\n\t      var distance = arguments.length <= 1 || arguments[1] === undefined ? this.distance() : arguments[1];\n\t\n\t      var minutes = new Date(duration / distance).getUTCMinutes(),\n\t          seconds = new Date(duration / distance).getUTCSeconds();\n\t\n\t      return {\n\t        minutes: minutes < 10 ? '0' + minutes : minutes,\n\t        seconds: seconds < 10 ? '0' + seconds : seconds\n\t      };\n\t    }\n\t\n\t    /**\n\t     * @typedef Elevation\n\t     * @type Object\n\t     * @property {object} elevation The minutes part of the pace time.\n\t     * @property {number} max The max elevation of the route.\n\t     * @property {number} min The min elevation of the route.\n\t     * @property {number} gain Elevation gained during run.\n\t     * @property {number} loss Elevation lost during run.\n\t     */\n\t\n\t    /**\n\t     * Returns elevation info of the run\n\t     * @return {Elevation} The Elevation information object\n\t     */\n\t\n\t  }, {\n\t    key: 'elevation',\n\t    value: function elevation() {\n\t      var eleForMinMax = [],\n\t          richElevation = [],\n\t          gain = 0,\n\t          loss = 0,\n\t          startTime = new Date(this.trackpoints[0].time).getTime(),\n\t          dist = 0;\n\t\n\t      for (var i = 0; i < this.trackpoints.length - 1; i++) {\n\t        var diff = this.trackpoints[i + 1].elevation - this.trackpoints[i].elevation,\n\t            time = new Date(this.trackpoints[i + 1].time).getTime(),\n\t            timeDiff = Math.abs(time - startTime);\n\t\n\t        dist += this.calcDistanceBetweenPoints(this.trackpoints[i], this.trackpoints[i + 1]);\n\t\n\t        if (diff < 0) {\n\t          loss += diff;\n\t        }\n\t\n\t        if (diff > 0) {\n\t          gain += diff;\n\t        }\n\t\n\t        eleForMinMax.push(this.trackpoints[i].elevation);\n\t        richElevation.push({ elevation: this.trackpoints[i].elevation, time: this.millisecondsToTime(timeDiff), dist: dist });\n\t      }\n\t\n\t      return {\n\t        elevation: richElevation,\n\t        max: Math.max.apply(null, eleForMinMax),\n\t        min: Math.min.apply(null, eleForMinMax),\n\t        loss: loss,\n\t        gain: gain\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Returns distance of the run\n\t     * @return {number} distance in kilometers.\n\t     */\n\t\n\t  }, {\n\t    key: 'distance',\n\t    value: function distance() {\n\t      var distanceInKm = 0;\n\t\n\t      for (var i = 0; i < this.trackpoints.length - 1; i++) {\n\t        distanceInKm += this.calcDistanceBetweenPoints(this.trackpoints[i], this.trackpoints[i + 1]);\n\t      }\n\t\n\t      return distanceInKm;\n\t    }\n\t\n\t    /**\n\t     * Returns distance betwene points\n\t     * @param {TrackPoint} wp1 Object with trackpoint info\n\t     * @param {TrackPoint} wp2 Object with trackpoint info\n\t     * @return {number} distance Distance between the points.\n\t     */\n\t\n\t  }, {\n\t    key: 'calcDistanceBetweenPoints',\n\t    value: function calcDistanceBetweenPoints(wp1, wp2) {\n\t      var point1 = {\n\t        lat: wp1.lat * (Math.PI / 180),\n\t        lon: wp1.lon * (Math.PI / 180),\n\t        alt: wp1.elevation / 1000\n\t      },\n\t          point2 = {\n\t        lat: wp2.lat * (Math.PI / 180),\n\t        lon: wp2.lon * (Math.PI / 180),\n\t        alt: wp2.elevation / 1000\n\t      },\n\t          dp = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin((point1.lat - point2.lat) / 2), 2) + Math.cos(point1.lat) * Math.cos(point2.lat) * Math.pow(Math.sin((point1.lon - point2.lon) / 2), 2))),\n\t          d = dp * 6366,\n\t          h = Math.sqrt(Math.pow(d, 2) + Math.pow(point2.alt - point1.alt, 2));\n\t\n\t      return h;\n\t    }\n\t  }]);\n\t\n\t  return GPX;\n\t}();\n\t\n\texports.default = GPX;\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** gpx.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap fddbf6286392c727d018\n **/","/**\n * GPX parser class\n * @class GPX\n */\nexport default class GPX{\n\n  /**\n   * GPX constructor.\n   * @param {string} gpxContent String of gpx XML data.\n   * @constructs GPX\n   */\n  constructor( gpxContent ){\n    /**\n     * string of gpx XML data.\n     * @member GPX#gpxContent\n     */\n    this.gpxContent = gpxContent;\n\n    /**\n     * The parsed gpx string into a DOM object.\n     * @member GPX#xmlDoc\n     */\n    this.xmlDoc = new DOMParser().parseFromString( this.gpxContent, 'application/xml' );\n\n    /**\n     * Object of all trackpoints in the gpx DOM.\n     * @member GPX#trkpts\n     */\n    this.trkpts = this.xmlDoc.querySelectorAll( 'trkpt' );\n\n    /**\n     * All trackpoints as an Array\n     * @member GPX#trackpoints\n     */\n    this.trackpoints = this.createJsonFromGpxDom();\n\n    if( this.trackpoints.length === 0 ){\n      throw new Error( 'This file has no trackpoints (trkpt)' );\n    }\n  }\n\n  /**\n   * @typedef TrackPoint\n   * @type Object\n   * @property {number} lon The lon coordinate of the trackpoint\n   * @property {number} lat The lat coordinate of the trackpoint\n   * @property {number} elevation The elevation in meters of the trackpoint\n   * @property {string} time The time of the trackpoint\n   */\n\n  /**\n   * Loops over gpx DOM and returns array of objects\n   * @return {TrackPoint} The trackpoint data\n   */\n  createJsonFromGpxDom(){\n    let trackpoints = [];\n\n    for( let trkpt = 0; trkpt < this.trkpts.length; trkpt++ ){\n      trackpoints.push( {\n        lon: parseFloat( this.trkpts[ trkpt ].getAttribute( 'lon' ) ),\n        lat: parseFloat( this.trkpts[ trkpt ].getAttribute( 'lat' ) ),\n        elevation: parseFloat( this.trkpts[ trkpt ].querySelector( 'ele' ).textContent ),\n        time: this.trkpts[ trkpt ].querySelector( 'time' ).textContent\n      } );\n    };\n\n    return trackpoints;\n  }\n\n  /**\n   * @typedef Duration\n   * @type Object\n   * @property {date} start The start time of the run as a Date object\n   * @property {date} end The end time of the run as a Date object\n   * @property {number} totalMS The duration of the run in miliseconds\n   * @property {string} total The duration of the run in human readable form\n   */\n\n  /**\n   * Returns the duration of the run.\n   * @return {Duration} The duration information of the run.\n   */\n  duration(){\n    let start = new Date( this.trackpoints[ 0 ].time ),\n      end = new Date( this.trackpoints[ this.trackpoints.length - 1 ].time ),\n      timeDiff = Math.abs( end.getTime() - start.getTime() ),\n      total = this.millisecondsToTime( timeDiff );\n\n    return {\n      start: start,\n      end: end,\n      totalMS: timeDiff,\n      total: total\n    };\n  }\n\n  /**\n   * Returns humanized time for miliseconds.\n   * @param {string} duration Duration in milliseconds\n   * @return {string} Readable time\n   */\n  millisecondsToTime( duration ){\n    let seconds = parseInt( ( duration / 1000 ) % 60, 10 ),\n      minutes = parseInt( ( duration / ( 1000 * 60 ) ) % 60, 10 ),\n      hours = parseInt( ( duration / ( 1000 * 60 * 60 ) ) % 24, 10 ),\n      days = parseInt( duration / ( 1000 * 60 * 60 * 24 ), 10 ),\n      hoursDays = parseInt( days * 24, 10 );\n\n    hours += hoursDays;\n    hours = ( hours < 10 ) ? '0' + hours : hours;\n    minutes = ( minutes < 10 ) ? '0' + minutes : minutes;\n    seconds = ( seconds < 10 ) ? '0' + seconds : seconds;\n    return ( hours === '00' ) ? minutes + ':' + seconds : hours + ':' + minutes + ':' + seconds;\n  }\n\n  /**\n   * @typedef Pace\n   * @type Object\n   * @property {number} minutes The minutes part of the pace time.\n   * @property {number} seconds The seconds part of the pace time.\n   */\n\n  /**\n   * Returns pace of the run.\n   * @param {number} duration Duration in milliseconds.\n   * @param {number} distance Distance in kilometers.\n   * @return {Pace} The Pace\n   */\n  pace( duration = this.duration().totalMS, distance = this.distance() ){\n    let minutes = new Date( duration / distance ).getUTCMinutes(),\n      seconds = new Date( duration / distance ).getUTCSeconds();\n\n    return {\n      minutes: ( minutes < 10 ) ? '0' + minutes : minutes,\n      seconds: ( seconds < 10 ) ? '0' + seconds : seconds\n    };\n  }\n\n  /**\n   * @typedef Elevation\n   * @type Object\n   * @property {object} elevation The minutes part of the pace time.\n   * @property {number} max The max elevation of the route.\n   * @property {number} min The min elevation of the route.\n   * @property {number} gain Elevation gained during run.\n   * @property {number} loss Elevation lost during run.\n   */\n\n  /**\n   * Returns elevation info of the run\n   * @return {Elevation} The Elevation information object\n   */\n  elevation(){\n    let eleForMinMax = [],\n      richElevation = [],\n      gain = 0, loss = 0,\n      startTime = new Date( this.trackpoints[ 0 ].time ).getTime(),\n      dist = 0;\n\n    for( let i = 0; i < this.trackpoints.length - 1; i++ ){\n      let diff = this.trackpoints[ i + 1 ].elevation - this.trackpoints[ i ].elevation,\n        time = new Date( this.trackpoints[ i + 1 ].time ).getTime(),\n        timeDiff = Math.abs( time - startTime );\n\n      dist += this.calcDistanceBetweenPoints( this.trackpoints[ i ], this.trackpoints[ i + 1 ] );\n\n      if( diff < 0 ){\n        loss += diff;\n      }\n\n      if( diff > 0 ){\n        gain += diff;\n      }\n\n      eleForMinMax.push( this.trackpoints[ i ].elevation );\n      richElevation.push( { elevation: this.trackpoints[ i ].elevation, time: this.millisecondsToTime( timeDiff ), dist: dist } );\n    }\n\n    return {\n      elevation: richElevation,\n      max: Math.max.apply( null, eleForMinMax ),\n      min: Math.min.apply( null, eleForMinMax ),\n      loss: loss,\n      gain: gain\n    };\n  }\n\n  /**\n   * Returns distance of the run\n   * @return {number} distance in kilometers.\n   */\n  distance(){\n    let distanceInKm = 0;\n\n    for( let i = 0; i < this.trackpoints.length - 1; i++ ){\n      distanceInKm += this.calcDistanceBetweenPoints( this.trackpoints[ i ], this.trackpoints[ i + 1 ] );\n    }\n\n    return distanceInKm;\n  }\n\n  /**\n   * Returns distance betwene points\n   * @param {TrackPoint} wp1 Object with trackpoint info\n   * @param {TrackPoint} wp2 Object with trackpoint info\n   * @return {number} distance Distance between the points.\n   */\n  calcDistanceBetweenPoints( wp1, wp2 ){\n    let point1 = {\n        lat: wp1.lat * ( Math.PI / 180 ),\n        lon: wp1.lon * ( Math.PI / 180 ),\n        alt: wp1.elevation / 1000\n      },\n      point2 = {\n        lat: wp2.lat * ( Math.PI / 180 ),\n        lon: wp2.lon * ( Math.PI / 180 ),\n        alt: wp2.elevation / 1000\n      },\n      dp = 2 * Math.asin( Math.sqrt( Math.pow( Math.sin( ( point1.lat - point2.lat ) / 2 ), 2 ) + Math.cos( point1.lat ) * Math.cos( point2.lat ) * Math.pow( Math.sin( ( point1.lon - point2.lon ) / 2 ), 2 ) ) ),\n      d = dp * 6366,\n      h = Math.sqrt( Math.pow( d, 2 ) + Math.pow( point2.alt - point1.alt, 2 ) );\n\n    return h;\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/index.js\n **/"],"sourceRoot":""}